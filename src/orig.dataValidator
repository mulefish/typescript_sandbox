
import { PASS, FAIL, Receipt, Rollup } from './types';

interface Price {
    saleWithoutTaxShipping: string;
    regularWithoutTaxShipping: string;
    taxOnly: string;
    isSale: boolean;
    displaySale: string;
    displayRegular: string;
}

interface Sku {
    price: Price;
    quantity: number;
    size: string;
    sku: string;
}

interface Product {
    categoryUnifiedId: string;
    unifiedId: string;
    productId: string;
    skuList: Sku[];
}
interface Name {
    unified: string;
    localized: string;
};
interface Collection {
    id: string;
    type: string;
    name: Name;
    productList: Product[];
}

interface Component {
    id?: string;
    type?: string;
    text?: string;
}

interface ProductInteraction {
    component: Component;
    collectionList: Collection[];
}

interface CollectionData {
    collectionList: Collection[];
}

let rollup: { [key: string]: Rollup } = {};
function footPrints(bool: boolean, whence: string) {
    if (rollup.hasOwnProperty(whence)) {
        if (bool === false) {
            rollup[whence].verdict = false
        }
        rollup[whence].seen++
    } else {
        rollup[whence] = {
            verdict: bool,
            seen: 1
        };
    }
}

function validatePrice(price: Price): boolean {
    const isOk = typeof price.saleWithoutTaxShipping === 'string' &&
        typeof price.regularWithoutTaxShipping === 'string';
    footPrints(isOk, "validatePrice")
    return isOk
}

function validateSku(sku: Sku): boolean {
    const isOk = validatePrice(sku.price) &&
        typeof sku.quantity === 'number' &&
        typeof sku.size === 'string' &&
        typeof sku.sku === 'string';
    footPrints(isOk, "validateSku")
    return isOk
}

function validateProduct(product: Product): boolean {
    const isOk = typeof product.categoryUnifiedId === 'string' &&
        typeof product.unifiedId === 'string' &&
        typeof product.productId === 'string' &&
        Array.isArray(product.skuList) && product.skuList.every(validateSku);

    footPrints(isOk, "validateProduct")
    return isOk
}

function validateCollection(collection: Collection): boolean {
    const isOk = typeof collection.id === 'string' &&
        typeof collection.type === 'string' &&
        typeof collection.name.unified === 'string' &&
        typeof collection.name.localized === 'string' &&
        Array.isArray(collection.productList) && collection.productList.every(validateProduct);

    footPrints(isOk, "validateCollection")

    return isOk
}

function validateComponent(component: Component): boolean {
    const isOk = typeof component.id === 'string' &&
        typeof component.type === 'string' &&
        typeof component.text === 'string';
    footPrints(isOk, "validateComponent")

    return isOk
}


function resetRollup() {
    rollup = {};
}

export function validateProductInteraction(pi: ProductInteraction): Receipt {
    resetRollup()
    const isOk = validateComponent(pi.component) &&
        Array.isArray(pi.collectionList) && pi.collectionList.every(validateCollection);

    let finding: Receipt = {
        verdict: isOk,
        receipt: rollup
    };

    return finding;
}
/* 
export function getParentNodes(node: any, parent: string | null = null): string[] {
    let parents: string[] = [];

    if (Array.isArray(node)) {
        // Node is an array, iterate over elements
        node.forEach((child, index) => {
            parents = parents.concat(getParentNodes(child, `${parent}[${index}]`));
        });
    } else if (node !== null && typeof node === 'object') {
        // Node is an object (not null and not an array), iterate over keys
        for (const key of Object.keys(node)) {
            const fullPath = parent ? `${parent}.${key}` : key;
            parents.push(fullPath); // Add the current path as a parent node
            parents = parents.concat(getParentNodes(node[key], fullPath));
        }
    }
    // Leaf nodes (primitives) are not added, only parent nodes are considered

    return parents;
}
*/
export function checkParentAgainstInterfaces(node: any, parent: string | null = null): Record<string, boolean> {
    let resultMap: Record<string, boolean> = {};

    if (Array.isArray(node)) {
        node.forEach((child, index) => {
            const results = checkParentAgainstInterfaces(child, `${parent}[${index}]`);
            resultMap = { ...resultMap, ...results };
        });
    } else if (node !== null && typeof node === 'object') {
        for (const key of Object.keys(node)) {
            const fullPath = parent ? `${parent}.${key}` : key;
            if (validators[key]) {
                resultMap[fullPath] = validators[key](node[key]);
            }

            const childResults = checkParentAgainstInterfaces(node[key], fullPath);
            resultMap = { ...resultMap, ...childResults };
        }
    }

    return resultMap;
}